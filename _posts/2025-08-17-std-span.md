---
layout: post
title:  std::span
date:   2025-08-17 11:10:06
categories: 
tags: 
---

* content
{:toc}

std::span 解决了长期以来 C++ 中处理连续数据序列（数组、缓冲区等）的通用性和安全性问题

**std::span 是什么？**

std::span 被定义为一个“非拥有（non-owning）的、指向一个连续对象序列的视图”

可以把它理解为一个“智能指针”，但它不指向单个对象，而是指向一段连续的内存。它内部只包含两个核心成员：

> 1. 一个指向序列开头的指针
> 2. 一个序列的长度

key point:

1. **非拥有 (Non-owning)：**这是与 std::vector 最根本的区别。std::span不负责其所指向内存的生命周期。它只是一个观察者或“视图”。当 std::span 本身被销毁时，它指向的数据不会被销毁。这使得 std::span 非常轻量，其大小通常就是两个指针的大小，创建和复制的开销极低

2. **连续内存 (Contiguous)：**std::span 只能用于操作内存地址连续的数据结构，例如 C 风格数组、std::array、std::vector 以及手动分配的内存块。它不能用于 std::list 或 std::map

**理解：**

1. std::vector<int> 就像一本书，它拥有所有的纸张和内容

2. std::span<int> 就像一个书签或者一个透明的尺子，你可以用它来标记或度量书中的某一段，但它本身不是书，书被烧掉了，书签还在，但它指向的内容已经无效了
为何需要 std::span？解决了什么痛点？

#### 痛点一：API 接口不统一

在 C++20 之前，如果想编写一个可以处理任何连续数据序列的函数，通常需要提供多个重载：
``` c++
// Before C++20
void process_data(const std::vector<int>& data);
void process_data(const std::array<int, 10>& data);
void process_data(const int* data, std::size_t size); // C-style
```

这种方式非常繁琐且容易出错

std::span 的解决方案：统一接口

``` c++
#include <span>
#include <vector>
#include <array>

// With C++20 std::span
void process_data(std::span<const int> data) { // 一个函数，接受所有！
    for (int val : data) {
        // ... process val
    }
}

void test() {
    std::vector<int> v = {1, 2, 3};
    std::array<int, 4> a = {4, 5, 6, 7};
    int c_array[] = {8, 9, 10};

    process_data(v);
    process_data(a);
    process_data(c_array); // 隐式转换为 span
}
```

std::span 提供了一个通用的词汇类型来表示“一个连续的数据序列”，极大地简化了API设计

#### 痛点二：C风格接口的安全性差
``` c++
void process_data(const int* data, std::size_t size) 这种接口非常危险。data 和 size 是两个独立的参数，很容易传错：
```

1. 传入的 size 大于 data 指向的实际内存大小，导致缓冲区溢出

2. 忘记传递 size 或者传了 nullptr

std::span 的解决方案：绑定指针和大小

std::span 将指针和大小封装在一个对象中，让它们始终保持同步

#### 痛点三：不必要的性能开销

有时只是想传递数据的一部分给一个函数。使用 std::vector 可能需要创建一个新的、只包含子集的 vector，这会涉及到昂贵的内存分配和数据拷贝

std::span 的解决方案：零开销的切片

std::span 的 subspan() 成员函数可以创建一个指向原始数据子集的视图，这个操作没有任何内存分配和拷贝，仅仅是创建了一个新的、包含不同指针和长度的 span 对象

创建 std::span

``` c++
#include <span>
#include <vector>
#include <array>

int c_array[] = {1, 2, 3, 4, 5};
std::vector<int> vec = {1, 2, 3, 4, 5};
std::array<int, 5> arr = {1, 2, 3, 4, 5};

// 1. 从 C 数组创建
std::span<int> s1(c_array); // 自动推导大小

// 2. 从 std::vector 创建
std::span<int> s2(vec);

// 3. 从 std::array 创建
std::span<int> s3(arr);

// 4. 从指针和长度创建 (与 C API 交互时常用)
std::span<int> s4(c_array, 3); // 指向 c_array 的前 3 个元素

// 5. 从迭代器创建
std::span<int> s5(vec.begin() + 1, vec.begin() + 4); // 指向 vec 的 [1, 2, 3]
```

核心操作

std::span 的接口和常见的容器很像：

``` c++
void inspect_span(std::span<const int> data) {
    if (data.empty()) return;

    // 访问大小
    std::cout << "Size: " << data.size() << std::endl;
    std::cout << "Size in bytes: " << data.size_bytes() << std::endl;

    // 访问元素
    std::cout << "First element: " << data.front() << std::endl;
    std::cout << "Last element: " << data.back() << std::endl;
    std::cout << "Element at index 1: " << data[1] << std::endl; // 不进行边界检查

    // 获取底层指针 (与 C API 交互)
    const int* p_data = data.data();

    // 迭代
    for(int val : data) { /* ... */ }
}
``` 

#### 切片 (Slicing)
这是 std::span 的一个强大功能，通过 subspan() 实现

```c++
// 假设 network_packet 是一个包含头部和载荷的缓冲区
std::vector<std::byte> network_packet = get_packet();
std::span<const std::byte> packet_view(network_packet);

// 假设头部是 8 字节
constexpr size_t header_size = 8;
std::span<const std::byte> header = packet_view.subspan(0, header_size);
std::span<const std::byte> payload = packet_view.subspan(header_size); // 从第8字节到末尾

// process_header 和 process_payload 函数可以安全地处理各自的数据视图
process_header(header);
process_payload(payload);
```

#### 静态大小 和 动态大小 (Fixed vs. Dynamic Extent)

std::span 有一个模板参数 Extent，用于在编译期指定大小。

- std::dynamic_extent：默认值，表示 span 的大小在运行时确定。
- <N>：一个具体的整数，表示 span 的大小是编译期常量

```c++
// 动态大小 (最常用)
void process(std::span<int> s);

// 静态大小 (编译期固定为3)
void process_3d_vector(std::span<float, 3> xyz) {
    // 编译器知道大小是3，可以进行优化，比如循环展开
    // xyz.size() 是一个编译期常量
}

float c_pos[] = {1.0, 2.0, 3.0, 4.0};
// process_3d_vector(c_pos); // 编译错误！c_pos 大小是4，不匹配
std::span<float, 4> s_pos(c_pos);
// process_3d_vector(s_pos); // 编译错误！大小不匹配

std::array<float, 3> arr_pos = {1.0, 2.0, 3.0};
process_3d_vector(arr_pos); // OK
```