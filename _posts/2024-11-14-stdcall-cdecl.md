---
layout: post
title:  __stdcall 和 __cdecl
date:   2024-11-14 17:02:52
categories: c/c++
tags: c/c++
---

* content
{:toc}

- __cdecl是C Declaration的缩写（declaration，声明），表示C/C++和MFC程序默认使用的调用约定：所有参数从右至左依次入栈，这些参数由调用者清理，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。因此，实现可变参数的函数只能使用该调用约定。由于每一个使用__cdecl约定的函数都要包含清理堆栈的代码，所以产生的可执行文件大小会比较大。__cdecl也可以写成 _cdecl。

- __stdcall是Standard Call的缩写，是C++的标准调用方式(不是默认)，用于调用Win32 API函数：所有参数从右至左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。这些堆栈中的参数由被调用的函数在返回后清理，使用的指令是ret X，X表示参数占用的字节数，CPU在ret之后自动弹出X个字节的堆栈空间，称为自动清栈。函数在编译的时候就必须确定参数个数，并且调用者必须严格控制参数的生成，不能多，也不能少，否则返回后会出错。__stdcall也可以写成_stdcall。

### 总结：

1、__cdecl和__stdcall都是参数从右到左入栈。

2、__cdecl是调用者负责清理栈中的参数，如A函数中调用B函数，参数由A函数负责清理；__stdcall是被调用者负责清理栈中的参数，如A函数中调用B函数，参数由B函数负责清理。

3、_cdecl调用方式不需要知道参数的个数，若要实现变参函数，则要使用这种调用方式，这种成为手动清理（因为调用函数需要生成清理代码）。而__stdcall因为参数栈空间由被调用者清理，则必须知道参数的个数(栈空间大小)，这种方式为自动清理（因为由被调函数清理，调用函数无需成清理）。

4、__stdcall 对比 __cdecl调用方式 ，__cdecl是调用者恢复堆栈的，假设有一百个不同的函数调用函数B，那么内存中就有一百段恢复堆栈的代码，__stdcall是被调用者恢复堆栈，只有在函数代码的结尾出现一次恢复堆栈的代码，所以节约空间。

5、恢复堆栈的代码是编译器根据你给它的调用方式自动生成的，所以无需考虑，而告诉编译器调用方式的意义就在这里。如果一方用__cdecl，而一方用__stdcall，可能出现没有人释放堆栈的情况，这明显是不允许的。

6、关键字__cdecl、__stdcall和__fastcall可以直接加在要输出的函数前，也可以在vs编译环境的Setting...->C/C++->Code Generation项选择。它们对应的命令行参数分别为/Gd、/Gz和/Gr。缺省状态为/Gd，即__cdecl。当加在输出函数前的关键字与编译环境中的选择不同时，直接加在输出函数前的关键字有效。

7、x64程序使用__fastcall方式

8、c默认方式是__cdecl(并且只有这种方式)，C++默认方式也是__cdecl，但可以修改。