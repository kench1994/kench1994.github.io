---
layout: post
title:  对称密码算法
date:   2022-11-10 16:25:32
categories: 加密学
tags: 加密学
---

* content
{:toc}

在密码学中，用于数据加密的算法主要有两种，分别是对称加密算法（Symmetric-keyAlgorithms）和非对称加密算法（AsymmetricalCryptography）

## 1、对称加密
对称加密算法有两种类型，分别是块密码算法（blockciphers）和流密码算法（streamciphers），表2-7和表2-8简单列举了常用的对称加密算法。

![errorEncoding](/assets/symmetric-encryption.png)

既然有这么多块密码算法，使用哪种算法呢？建议使用AES算法，该算法是对称加密算法的标准算法，后续也主要以AES算法讲解。

美国国家标准与技术研究院（NationalInstituteofStandardsandTechnology,NIST)对众多的对称加密算法进行了考核，从安全性和效率进行了多方面评测，最终选取Rijndael算法作为对称加密算法的标准。以Rijndael算法为原型，创建了AES(AdvancedEncryptionStandard）算法，AES就是最终的对称加密算法标准。Rijndael算法和AES算法略微不同，但在理解的时候可以认为是相同的算法。

### 1.1 流密码算法

在介绍流密码算法之前，先简单介绍下一次性密码本（one-timepad）的概念，一次性密码本诞生了流密码算法。一次性密码本非常简单，大概原理如下：

- 明文与同样长度的序列进行XOR运算得到密文
- 密文与加密使用的序列再进行XOR运算就会得到原始明文。

一次性密钥本的关键在于：

- 密钥每次必须不一样，否则同一个明文和密钥就会获得相同的内容
- 一次性密钥本是无法破解的，原因就在于破解者无法确认破解的明文就是原始明文

理解一次性密钥本之后，就可以大概明白流密码算法的工作原理了，以RC4流密码算法为例，关键就在于算法内部生成了一个伪随机的密钥流（keystream），密钥流的特点如下：

- 密钥流的长度和密钥长度是一样的
- 密钥流是一个伪随机数，是不可预测的
- 生成伪随机数都需要一个种子（seed），种子就是RC4算法的密钥，基于同样一个密钥（或者称为种子〉，加密者和解密者能够获取相同的密钥流。

流密码算法之所以称为流密码算法，就在于每次XOR运算的时候，是连续对数据流进行运算的一种算法，每次处理的数据流大小一般是一字节。流密码算法可以并行处理，运算速度非常快，但目前RC4已经被证明是不安全的了，建议使用接下来讲解的块密码算法。

### 1.2 块密码算法

块密码算法在运算（加密或者解密）的时候，不是一次性完成的，每次对固定长度的数据块（block）进行处理，也就是说完成一次加密或者解密可能要经过多次运算，最终得到的密文长度和明文长度是一样的。

数据块的长度就称为分组长度（blocksize），由于大部分明文的长度远远大于分组长度，所有要经过多次迭代运算才能得到最终的密文或明文，块密码算法有多种选代模式(Block cipher modes of operation),迭代模式也可以称为分组模式。

通过以上的描述可以了解：

- 块密码算法不是一次运算完成的，块密码算法有多种选代模式，每次选代固定长度的数据块，这是需要重点理解的
- 分组长度和密钥长度并没有必然的联系，对称加密算法的安全性取决于密钥长度
- 如果明文（或者密文〉的长度除以分组长度不是整数倍，需要对明文进行填充（后续章节会讲解〉，保证最终处理的数据长度是分组长度的整数块。

块密码算法有多种选代模式，接下来讲解几个比较有代表性的法代模式。


#### 1.2.1 ECB 模式 
ECB模式（ElectronicCodebook）是最简单的一种选代模式，这种选代模式是存在安全问题的，一般不建议使用。

- 将明文拆分成多个数据块，每个数据块的长度等于分组长度，如果最后一个数据块长度小于分组长度，需要进行填充保证最后一个数据块长度等于分组长度
- 依次对每个数据块进行法代得到每个数据块的密文分组，将所有密文分组组合在一起就得到最终的密文，密文长度等同于明文长度。
- 将密文拆分成多个数据块，每个数据块的长度等于分组长度
- 依次对每个数据块进行法代得到每个数据块的明文分组，最后一个明文分组要去除填充值，最终将明文分组组合在一起就得到最终的明文

ECB模式最大的特点就是**每个迭代过程都是独立的**，是可以并行处理的，能够加快运算速度。由于固定的明文和密钥每次运算的结果都是相同的，这会造成很多的安全问题。

#### 1.2.2 CBC 模式
CBC模式（CipherBlockChaining）是比较常见的一种选代模式，解决了ECB模式的安全问题

**加密过程**

- 将密文拆分成多个数据块，每个数据块的长度等于分组长度，如果最后一个数据块长度小于分组长度，需要进行填充保证最后一个数据块长度等于分组长度
- 首先处理第一个数据块，生成一个随机的初始化向量IV(InitializationVector),初始化向量和第一个数据块进行XOR运算，运算的结果经过加密得到第一个密文分组
- 接着处理后续的数据块，第n个数据块会和前n-1密文分组进行XOR运算，运算的结果再进行加密得到第n个密文分组。对于第一个数据块来说，它的前一个密文分组就是初始化向量
- 将各个密文分组组合在一起就是完整的密文

**解密过程**

- 将密文拆分成多个数据块，每个数据块的长度等于分组长度
- 对于解密者来说，初始化向量W是随同密文发送给解密者的，而且该值是不加密的。
- 初始化向量和第一个数据块进行XOR运算，运算的结果经过解密得到第一个明文分组
- 接着处理后续的数据块，第n个数据块会和前n-l密文分组进行XOR运算，运算的结果再进行解密得到第n个明文分组，最后一个明文分组要去除填充值
- 将各个明文分组组合在一起就是最终的明文。

CBC加密模式非常常见，但是使用起来很烦琐，如果应用不当，很容易出现问题，需要注意以下几点：
- CBC模式引入了初始化向量的概念，初始化向量是一个随机数，长度等于分组长度。
- 初始化向量必须每次都不一样，有了随机的初始化向量，同样的明文和密钥最终得到的密文是不一样的，解决了ECB模式存在的安全问题
- 一般情况下初始化向量和密文是同时传输给解密者的，而且初始化向量是不加密的
- 每个数据块（明文或者密文）和上－个数据块之间都是有关联的，上一个数据块稍有变化，最终得到的结果完全不一样
- 迭代运算数据块不能并行处理，只有处理完第n个数据块，才能继续处理第n+I个数据块。


CBC模式和CTR模式是最常用的两种选代模式，表2-9（暂缺）列举了所有的迭代模式。

![errorEncoding](/assets/cryptokey.png)


